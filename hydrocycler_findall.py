#!/usr/bin/env  python  

import sys, os
import copy, time
from datetime import datetime
import numpy as np
from scipy.spatial import KDTree as kd
import johnson

ts = datetime.now().strftime("%y%m%d%H%M%S%f")
sys.setrecursionlimit(10000)

#==============
# cutoffs
oobondlim = 3.2
hobondlim = 1.2
hooangle = 0.523599    # 30 degrees
# hooangle = 0.785398    #  45 degrees

#==============
# Log all output 

class Logger(object):

    def __init__(self):
        self.terminal = sys.stdout
        self.log = open("hydrocycler3_findall-%s.out"%ts, "a")
    def write(self, message):
        self.terminal.write(message)
        self.log.write(message) 
    def flush(self): 
        self.terminal.flush(); 
        self.log.flush()

sys.stdout = Logger()

#==============
def reverseit (o1, o2, h, theta):

    dist = np.linalg.norm(o2-o1)
    unitv = (o2-o1)/dist
    displacement = dist - 2*np.linalg.norm(h-o1)*np.cos(theta)
    return h + unitv * displacement

#==============
def modifycycle(cycle, xyzdict): 

    global trio
    previous = -1
    for node in cycle:
        if (previous, node) in trio:
            newh = trio[(node, previous)][2]                  
            xyzdict[('H',trio[(previous, node)][0])] = newh          
        previous = node
    newh = trio[(cycle[0], previous)][2] 
    xyzdict[('H',trio[(previous, cycle[0])][0])] = newh
    return xyzdict

#==============
def exportcartesian (xyzdict, fd):

  outputs = [sys.stdout, fd ]
  for output in outputs: 
   print(len(xyzdict.keys()),file=output)
   print("This was generated by Hydrocycler (Felipe, 2022)", file=output)
   for key in xyzdict:
     print(key[0], *(x for x in xyzdict[key]), file=output)
   print('\n\n', file=output)

#==============
def exportbatchjob (filename):
    
  global batchjob
  print ("g16 %s.com & \nwait"%(filename), file=batchjob)


#==============
def isanhbond(h, o1, o2):
 
    a = h - o1
    ia = a/np.linalg.norm(a)
    b = o2 - o1
    ib = b/np.linalg.norm(b)
    theta = np.arccos(np.dot (ia, ib))
    if theta < hooangle:
        return [1, theta]
    else:
        return [0, 0.0]     

#==============
def gettrio (inp):

    [ ocoords, hcoords, xcoords, xyzdict1 ] = createarrays (inp)
    [ograph, trio1] = findcycles (ocoords,  hcoords)
    return trio1

#===============
def createarrays (inp):

    hinput = []
    oinput = []
    xinput = []
    xyzdict1 = {}
    ocount = 0
    hcount = 0
    xcount = 0

    for line in inp:
        toks = line.split()
        count = 0
        if len(toks) >= 3:
            if toks[0] == 'H':
                hinput.append ([float(toks[1]), float(toks[2]), float(toks[3])])
                count = hcount
                hcount = hcount + 1
            elif toks[0] == 'O':
                oinput.append([float(toks[1]), float(toks[2]), float(toks[3])])
                count = ocount 
                ocount = ocount + 1
            else:
                xinput.append([float(toks[1]), float(toks[2]), float(toks[3])])     
                count = xcount
                xcount = xcount + 1        
            xyzdict1 [(toks[0], count)] = np.array([ float(toks[1]), float(toks[2]), float(toks[3]) ])  

    ocoords = np.array(oinput)
    hcoords = np.array(hinput)
    xcoords = np.array(xinput)

    return [ ocoords, hcoords, xcoords, xyzdict1 ]

#=============
def recreatearrays (xyzdict):

    hinput = []
    oinput = []
    xinput = []
  
    for (toks, count) in xyzdict:
        if toks == 'H':
          hinput.append (xyzdict[toks, count])
        elif toks[0] == 'O':
          oinput.append (xyzdict[toks, count])
        else:
          xinput.append (xyzdict[toks, count]) 
  
    ocoords = np.array(oinput)
    hcoords = np.array(hinput)
    xcoords = np.array(xinput)

    return [ ocoords, hcoords, xcoords ]

#=============
def findcycles (ocoords,  hcoords):

    okdt = kd(ocoords)                    # kdtree to find neighbors
    hkdt = kd(hcoords)

    count = 0
    ograph = {}
    trio1 = {}

    for oatom in ocoords:                 # go through each O coordinate
        oidx = okdt.query_ball_point(oatom, r=oobondlim )  # an O atom has neighbors
        for neighoidx in oidx:               # oxygen pair pair to test H-bond connection
            dist = np.linalg.norm(oatom - ocoords[neighoidx])
            if dist > 0.01:                     # exclude itself from generating the trio1 
                hidx = hkdt.query_ball_point(oatom, r=hobondlim)
                for neighhidx in hidx:    
                    hbondtest = isanhbond(hcoords[neighhidx], oatom, ocoords[neighoidx]) 
                    if hbondtest[0] == 1:                                     # found an H-bond 
                        trio1 [(count,neighoidx)] = [neighhidx, hbondtest[1], hcoords[neighhidx]] 
                        o2 = ocoords[neighoidx]
                        o1 = ocoords[count]
                        h  = hcoords[neighhidx]
                        newh = reverseit (o1, o2, h, hbondtest[1])
                        trio1 [(neighoidx, count)] = [neighhidx, hbondtest[1], newh]
                        if count in ograph:
                            ograph[count].append(neighoidx)
                        else:
                            ograph[count] = [neighoidx]
        if count not in ograph:                   # terminal OH need keys
            ograph[count] = []
        count = count + 1
    return [ograph, trio1]

#==============
def fn ( files ):  
  
    global trio 
    global cyclesdict

    fileslocal = files.copy()
    fileschild =[]

    for file in fileslocal:                                     # open up current file
        print ("Processing %s for cycles"%file)
        string = open ( file, 'r' ).readlines()[2:] 
        [ocoords1, hcoords1, xcoords1, xyzdictmaster] = createarrays (string) 
        [ograph1, trio1] = findcycles (ocoords1, hcoords1)
        cycles = tuple(johnson.simple_cycles(ograph1))            # determine signature using
        cycles_srt = sorted(tuple(johnson.simple_cycles(ograph1)))            # determine signature using
        cycles_sig = tuple([ x for sublist in cycles_srt for x in sublist ]) # cycles for uniqueness 
        print ("   has signature %s"%str(cycles_sig))
        if (cycles_sig) not in cyclesdict:
            cyclesdict[cycles_sig]="DONE"                             # mark this file read

            for cycle in cycles:                                      # we go through each cycle
                xyzdict = copy.deepcopy(xyzdictmaster)                  # to create a file
                xyzdict = modifycycle(cycle, xyzdict)  
                [ocoords2, hcoords2, xcoords2] = recreatearrays (xyzdict)
                [ograph2, trio2] = findcycles (ocoords2, hcoords2)
                cycles2_srt = sorted(tuple(johnson.simple_cycles(ograph2)))
                cycles_sig2 = tuple([ x for sublist2 in cycles2_srt for x in sublist2 ])
        
                if (cycles_sig2) not in cyclesdict:                      # export this cartesian
                    nts = datetime.now().strftime("%y%m%d%H%M%S%f")         
                    filen = str(os.path.splitext(filename)[0]).split("/")[-1] 
                    fd = open("%s-%s.xyz"%(filen,nts), "w")
                    print ("%s-%s.xyz"%(filen,nts))

                    fileschild.append("%s-%s.xyz"%(filen,nts))              # pass these to fn 
                    exportcartesian(xyzdict, fd)
                    exportbatchjob("%s-%s.xyz"%(filen,nts))
                    fd.close()
#                else:
#                    pass
 
                    if len(fileschild) > 0:
                        fn (fileschild) 

#=============
print (" Calculating directed graphs with |O-H> nodes and H-bond edges.")
print (" H-bond parameters:")
print ("   H--O distance: %sA-%sA"%(hobondlim, oobondlim))
print ("   H-O--O angle:  <%s degrees \n"%int((hooangle*180/3.14159)))

batchjob = open("batchjob-%s.sh"%ts, "a") 

files = []
cyclesdict = {}

argv = sys.argv[1:]
argc  = len(sys.argv)
command = sys.argv[0].split('/')[len(sys.argv[0].split('/')) - 1] 
if not argv:
   print("Usage: %s [file]" % command )
   print ("No stdin option for this command. Use file argument")
elif argc == 2:
   for filename in argv:
     files.append(filename) 
     inp = open ( filename, 'r' ).readlines()[2:] 
     trio = gettrio (inp)
     print ("Processing with trios:")
     for key in trio:
         print ("\t%s\t%s"%(str(key),str(trio[key])) , )
     fn ( files )
     print ("\n\nThank you for using Hydrocycler!\n\n")
     sigdict_fd = open ("%s-%s.sig"%(filename,ts), "w")
     print (cyclesdict, file = sigdict_fd )

else:
   print("Usage: %s [file]" % command )


